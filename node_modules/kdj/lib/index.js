'use strict';

const isNumber = subject => typeof subject === 'number';

const isArray = Array.isArray;

// Dynamic Weighted Moving Average

// @param {Number|Array.<Number>} alpha
var dma = (data, alpha, noHead) => {

  const length = data.length;

  if (alpha > 1) {
    return Array(length)
  }

  if (alpha === 1) {
    return data.slice()
  }

  const noArrayWeight = !isArray(alpha);
  const ret = [];

  let datum;

  // period `i`
  let i = 0;

  // `s` is the value of the DWMA at any time period `i`
  let s = 0;

  // Handles head
  for (; i < length; i ++) {
    datum = data[i];

    if (
      isNumber(datum)
      && (
        noArrayWeight
        || isNumber(datum)
      )
    ) {

      ret[i] = noHead
        ? 0
        : datum;

      s = datum;
      i ++;

      break
    }
  }

  // Dynamic weights: an array of weights
  // Ref:
  // https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
  // with a dynamic alpha
  if (!noArrayWeight) {
    for (; i < length; i ++) {
      datum = data[i];

      isNumber(datum) && isNumber(alpha[i])
        ? s =
          ret[i] = alpha[i] * datum + (1 - alpha[i]) * s
        : ret[i] = ret[i - 1];
    }

    return ret
  }

  const o = 1 - alpha;

  // Fixed alpha
  for (; i < length; i++) {
    datum = data[i];

    isNumber(datum)
      ? s =
        ret[i] = alpha * datum + o * s
      : ret[i] = ret[i - 1];
  }

  return ret
};

// Smoothed moving average

var sma = (data, size, times = 1) => dma(data, times / size, 1);

// Exponential moving average with 86% total weight

// simple moving average

// Weighted moving average

const error = (
  message
  // code
) => {
  const e = new Error(message);

  // if (code) {
  //   e.code = code
  // }

  throw e
};


const manipulate2Array = (a, b, mutator) => {
  if (a.length !== b.length) {
    error('the length of arrays not match');
  }

  return a.map((x, i) => mutator(x, b[i]))
};


const manipulateArray = (a, b, mutator) => {
  return a.map(x => mutator(x, b))
};


const isArray$1 = (a, b) => [a, b].map(Array.isArray);

const cleanArray = (array) => {
  array.forEach((item, i) => {
    if (item !== item) {
      delete array[i];
    }
  });
};

const orderUnaware = (
  a, b, mutator, mutatorReverse,
  ensureNumber
) => {
  const [A, B] = isArray$1(a, b);

  const ret = A
    ? B
      ? manipulate2Array(a, b, mutator)
      : manipulateArray(a, b, mutator)
    : B
      ? manipulateArray(b, a, mutatorReverse)
      : error('at least one array is required');

  if (ensureNumber) {
    cleanArray(ret);
  }

  return ret
};


const orderAware = (
  a, b, mutator,
  ensureNumber
) => {
  const [A, B] = isArray$1(a, b);

  const ret = A
    ? B
      ? manipulate2Array(a, b, mutator)
      : manipulateArray(a, b, mutator)
    : error('the first argument must be an array');

  if (ensureNumber) {
    cleanArray(ret);
  }

  return ret
};

const sub = (a, b) => a - b;

var sub$1 = (a, b, n) => orderAware(a, b, sub, n);

const mul = (a, b) => a * b;

var mul$1 = (a, b, n) => orderUnaware(a, b, mul, mul, n);

const div = (a, b) => {
  if (b === 0) {
    error('divide by zero');
  }

  return a / b
};

var div$1 = (a, b, n) => orderAware(a, b, div, n);

const compare = (data, size, comparer) => {
  const length = data.length;

  if (size > length) {
    return Array(length)
  }

  if (!size) {
    return data.reduce(comparer)
  }

  if (size <= 1) {
    return data.slice()
  }

  let i = size - 1;
  const ret = [];

  for (; i < length; i ++) {
    ret[i] = reduce(data, i - size + 1, i + 1, comparer);
  }

  return ret
};


// @param {Number} start index to start [
// @param {Number} end index less than )
// -> [start, end)
const reduce = (array, start, end, reducer) => {
  let prev;
  let i = start;

  for (; i < end; i ++) if (i in array) {
    if (prev === undefined) {
      prev = array[i];
      continue
    }
    
    prev = reducer(prev, array[i]);
  }

  return prev
};


const hhv = (data, size) =>
  compare(data, size, (a, b) => Math.max(a, b));

const llv = (data, size) =>
  compare(data, size, (a, b) => Math.min(a, b));

const UPPER = 100;
const LOWER = 0;

const clean = n => Math.min(UPPER, Math.max(LOWER, n));

var index = ((closePrices, lowPrices, highPrices, periods = 9, kPeriods = 3, dPeriods = 3, kTimes = 3, dTimes = 2) => {

  const lowest = llv(lowPrices, periods);
  const highest = hhv(highPrices, periods);

  const u = div$1(mul$1(sub$1(closePrices, lowest, 1), UPPER, 1), sub$1(highest, lowest, 1));

  const ks = sma(u, kPeriods);
  const ds = sma(ks, dPeriods);
  const js = sub$1(mul$1(kTimes, ks, 1), mul$1(dTimes, ds, 1), 1);

  return {
    K: ks.map(clean),
    D: ds.map(clean),
    J: js.map(clean)
  };
});

module.exports = index;
