const ccxt = require('ccxt');
const talib = require('talib');
const { sendTelegramMessage } = require('./telegram');

// Set up the exchange and symbol
const exchange = new ccxt.binance({ enableRateLimit: true });
const symbol = 'BTC/USDT';

// Set up the Keltner Channels and EMA
const KeltnerPeriod = 20;
const KeltnerMultiplier = 2;
const EMAPeriod = 10;

// Set up the filter
const SMAPeriod = 5;

// Set up the indicators for filtering
const RSIPeriod = 14;
const RSIUpperThreshold = 70;
const RSILowerThreshold = 30;

const MACDFastPeriod = 12;
const MACDSlowPeriod = 26;
const MACDSignalPeriod = 9;

let lastPrice = null;

(async () => {
  while (true) {
    // Get the current price
    const ticker = await exchange.fetchTicker(symbol);
    const price = ticker.last;

    // Get the Keltner Channels and EMA
    const keltner = await getKeltnerValues(exchange, symbol, KeltnerPeriod, KeltnerMultiplier);
    const ema = await getEMAValues(exchange, symbol, EMAPeriod);

    // Get the filter value
    const sma = await getSMAValues(exchange, symbol, SMAPeriod);

    // Get the indicators for filtering
    const rsi = await getRSIValues(exchange, symbol, RSIPeriod);
    const macd = await getMACDValues(exchange, symbol, MACDFastPeriod, MACDSlowPeriod, MACDSignalPeriod);

    // Check for buy signal
    if (
      lastPrice !== null &&
      price > ema[ema.length - 1] &&
      price > keltner.upper &&
      sma[sma.length - 1] > ema[ema.length - 1] &&
      rsi[rsi.length - 1] < RSIUpperThreshold &&
      macd.macd[macd.macd.length - 1] > macd.signal[macd.signal.length - 1] &&
      macd.histogram[macd.histogram.length - 1] > 0
    ) {
      // Send a Telegram message
      const message = `Buy signal detected for ${symbol} at ${price}`;
      sendTelegramMessage(message);
    }

    // Check for sell signal
    if (
      lastPrice !== null &&
      price < ema[ema.length - 1] &&
      price < keltner.lower &&
      sma[sma.length - 1] < ema[ema.length - 1] &&
      rsi[rsi.length - 1] > RSILowerThreshold &&
      macd.signal[macd.signal.length - 1] &&
      macd.histogram[macd.histogram.length - 1] < 0
    ) {
      // Send a Telegram message
      const message = `Sell signal detected for ${symbol} at ${price}`;
      sendTelegramMessage(message);
    }

    // Set the last price
    lastPrice = price;

    // Wait for the next iteration
    await new Promise((resolve) => setTimeout(resolve, 1000));
  }
})();

async function getKeltnerValues(exchange, symbol, period, multiplier) {
  const candles = await exchange.fetchOHLCV(symbol, '1m', undefined, period);
  const close = candles.map((candle) => candle[4]);
  const atr = talib.execute({
    name: 'ATR',
    startIdx: 0,
    endIdx: close.length - 1,
    inReal: close,
    optInTimePeriod: period,
  }).result.outReal;
  const middle = talib.execute({
    name: 'EMA',
    startIdx: 0,
    endIdx: close.length - 1,
    inReal: close,
    optInTimePeriod: period,
  }).result.outReal;
  const upper = middle.map((m, i) => m + multiplier * atr[i]);
  const lower = middle.map((m, i) => m - multiplier * atr[i]);
  return { middle: middle[middle.length - 1], upper: upper[upper.length - 1], lower: lower[lower.length - 1] };
}

async function getEMAValues(exchange, symbol, period) {
  const candles = await exchange.fetchOHLCV(symbol, '1m', undefined, period);
  const close = candles.map((candle) => candle[4]);
  const ema = talib.execute({
    name: 'EMA',
    startIdx: 0,
    endIdx: close.length - 1,
    inReal: close,
    optInTimePeriod: period,
  }).result.outReal;
  return ema;
}

async function getSMAValues(exchange, symbol, period) {
  const candles = await exchange.fetchOHLCV(symbol, '1m', undefined, period);
  const close = candles.map((candle) => candle[4]);
  const sma = talib.execute({
    name: 'SMA',
    startIdx: 0,
    endIdx: close.length - 1,
    inReal: close,
    optInTimePeriod: period,
  }).result.outReal;
  return sma;
}

async function getRSIValues(exchange, symbol, period) {
  const candles = await exchange.fetchOHLCV(symbol, '1m', undefined, period);
  const close = candles.map((candle) => candle[4]);
  const rsi

